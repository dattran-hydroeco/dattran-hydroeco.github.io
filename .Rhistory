tinytex::install_tinytex()
install.packages("rmarkdown")
install.packages("rmarkdown")
install.packages("knitr")
############################################
# Stochastic Water Demand Model Illustration
############################################
# Load libraries
library(ggplot2)
library(dplyr)
library(tidyr)
set.seed(123)
###############################
# 1. Define Demand Function
###############################
# Q = alpha - beta*Price + gamma*Income + stochastic shock
alpha <- 120      # baseline demand
beta  <- 2.5      # price elasticity parameter
gamma <- 0.04     # income effect
###############################
# 2. Simulate Stochastic Inputs
###############################
n_sim  <- 200      # number of stochastic realizations
T      <- 30       # time periods
# Price path (can represent tariff or scarcity pricing)
price <- seq(10, 40, length.out = T)
# Income trend
income <- seq(40000, 50000, length.out = T)
# Storage object
results <- data.frame()
for(i in 1:n_sim){
shock <- rnorm(T, mean = 0, sd = 8)   # stochastic demand shock
Q <- alpha - beta*price + gamma*income + shock
temp <- data.frame(
sim = i,
time = 1:T,
price = price,
income = income,
demand = Q
)
results <- rbind(results, temp)
}
###############################
# 3. Plot A: Demand Curves Under Uncertainty
###############################
plot1 <- results %>%
filter(time == 15) %>%   # single time slice
ggplot(aes(x = price, y = demand, group = sim)) +
geom_line(alpha = 0.1) +
labs(
title = "Stochastic Water Demand Curves",
x = "Water Price",
y = "Water Demand"
) +
theme_minimal()
print(plot1)
###############################
# 4. Plot B: Time Series Fan Chart
###############################
summary_df <- results %>%
group_by(time) %>%
summarise(
p10 = quantile(demand, 0.10),
p50 = quantile(demand, 0.50),
p90 = quantile(demand, 0.90)
)
plot2 <- ggplot(summary_df, aes(x = time)) +
geom_ribbon(aes(ymin = p10, ymax = p90), alpha = 0.3) +
geom_line(aes(y = p50)) +
labs(
title = "Stochastic Water Demand Trajectories",
x = "Time",
y = "Water Demand"
) +
theme_minimal()
print(plot2)
###############################
# 5. Plot C: Probability Distribution of Demand
###############################
plot3 <- results %>%
filter(time == T) %>%   # final period distribution
ggplot(aes(x = demand)) +
geom_histogram(bins = 30) +
labs(
title = "Distribution of Water Demand",
x = "Water Demand",
y = "Frequency"
) +
theme_minimal()
print(plot3)
# groundwater_dp.R
# Finite-horizon DP for profit-max farmer and computation of shadow values
rm(list=ls()); library(pracma)  # pracma for interp1 if needed
install.packages("pracma")
# groundwater_dp.R
# Finite-horizon DP for profit-max farmer and computation of shadow values
rm(list=ls()); library(pracma)  # pracma for interp1 if needed
# PARAMETERS
T <- 20                # horizon
beta <- 1/(1+0.03)     # discount factor, r=3%
Smax <- 100            # max stock
nS <- 501              # grid points
Sgrid <- seq(0, Smax, length.out = nS)
a <- rep(1.0, T+1)     # recharge each period (can be vector)
# Profit function (example quadratic): pi(w) = p*w - 0.5*alpha*w^2
p <- 10; alpha <- 1.0
pi_fun <- function(w) p*w - 0.5*alpha*w^2
# Feasibility: for each S, w in [0, S + a[t]]
# Value arrays
V <- matrix(0, nrow = nS, ncol = T+1)     # V[,t+1] is value at time t
policy <- matrix(0, nrow = nS, ncol = T+1)
# Terminal value: optional salvage function. Here zero.
V[,T+1] <- 0
# Backward induction
for (t in T:0) {
for (i in 1:nS) {
S <- Sgrid[i]
wmax <- S + a[t+1]   # a indexed by 1..T+1
# candidate w grid (coarse) - can refine with optimization
w_cand <- seq(0, wmax, length.out = 200)
# compute RHS
nextS <- pmax(0, S - w_cand + a[t+1])   # enforce nonneg stock
# interpolate V_{t+1} at nextS
Vnext <- approx(Sgrid, V[,t+2], xout = nextS, rule=2)$y
RHS <- pi_fun(w_cand) + beta * Vnext
jbest <- which.max(RHS)
V[i, t+1] <- RHS[jbest]
policy[i, t+1] <- w_cand[jbest]
}
}
